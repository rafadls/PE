sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(id, mean)) +        # ggplot2 plot with confidence intervals
geom_point() +
geom_errorbar(aes(ymin = left_bound, ymax = right_bound))
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 5000
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(c(1)))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 5000
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(c(1,2)))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 5000
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(c(1)))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
View(bool_c)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 5000
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:500), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:500), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:500), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1) +
geom_vline(xintercept = media_poblacional)
df = read.csv('marketing_campaign.csv', sep='\t')
df = read.csv('marketing_campaign.csv', sep='\t')
df = read.csv('marketing_campaign.csv', sep='\t')
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
Rscript.exe -e "Sys.getenv('R_LIBS_USER')"
library.path <- .libPaths()
library("timeseries", lib.loc = library.path)
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
install.packages("scatterplot3d")
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
df = read.csv('marketing_campaign.csv', sep='\t')
df = read.csv('marketing_campaign.csv', sep='\t')
directory <- ("./specdata/")
df = read.csv('marketing_campaign.csv', sep='\t')
setwd("C:/Users/Rafael/Desktop/U_2021_2/PE/T3")
df = read.csv('marketing_campaign.csv', sep='\t')
df
df$Income
df$Income.mean
df$Income.mean()
mean(df$Income)
mean(df$Income, na.remuve=TRUE)
mean(df$Income, na.rm=TRUE)
sqrt(1)
2^2
2^3
(2^3)/2
length(c(1,2))
df = read.csv('marketing_campaign.csv', sep='\t')
# Implementación de Z-test one-sided y two-sided
# Puede utilizar este esqueleto
z_test <- function(data1=NULL, sigma1=0.5, data2=NULL, sigma2=0.5,
mu.Ha=0, test.type = c('one-sided','two-sided'),
verbose=TRUE){
if(length(test.type)>=2){
print("Por favor escoge un tipo de Test: ´one-sided´ o ´two-sided´ ")
return()
}
else if(length(test.type)==1 && !(test.type %in% c('menor','mayor','two-sided'))){
print("Por favor escoge un tipo de Test: ´menor´, ´mayor´ o ´two-sided´")
return()
}
else if(is.null(data2)){
data_1_mean = mean(data1, na.rm=TRUE)
# P-value
if(test.type=='menor'){
p_value = pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='two-sided'){
if(data_1_mean>=mu.Ha){
p_value = (1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
else if(data_1_mean<mu.Ha){
p_value = (pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
}
# Texto de Salida
if(verbose){
cat("\tOne-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)), "\nZ=", Z_score,
"P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
else if(!is.null(data2)){
# Hypothesis test
data_1_mean = mean(data1, na.rm=TRUE)
data_2_mean = mean(data2, na.rm=TRUE)
resta = data_1_mean - data_2_mean
sigma_resta = sqrt((sigma1^2)/length(data1) + (sigma1^2)/length(data1))
# p-value
if(test.type=='menor'){
p_value = pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='two-sided'){
if(resta>=0){
p_value = (1 - pnorm(resta,mean=0, sd=sigma_resta))*2
}
else if(resta<0){
p_value = (pnorm(resta,mean=0, sd=sigma_resta))*2
}
}
# Texto de Salida
if(verbose){
cat("\tTwo-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)),"y",
deparse(substitute(data2)), "\nZ=",
Z_score, "P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
}
df$Income-df$Education
df$Income~df$Education
hola = df$Income~df$Education
hola = df$Income-df$Education
hola = df$Income-df$Education
df$Income-df$Education
View(df)
View(df)
filter(df, Education == 'PhD')
filter(df, Education == 'PhD')$Income
df$Education
vec_income_PhD = filter(df, Education == 'PhD')$Income
vec_income_Master = filter(df, Education == 'Master')$Income
vec_income_Graduation = filter(df, Education == 'Graduation')$Income
vec_income_PhD = filter(df, Education == 'PhD')$Income
vec_income_Master = filter(df, Education == 'Master')$Income
vec_income_Graduation = filter(df, Education == 'Graduation')$Income
z.test.multiple_testing <- function(){
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
p_value_2 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_Master, sigma2=20160, test.type='two-sided', verbose=TRUE)
p_value_3 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_PhD, sigma2=20615, test.type='two-sided', verbose=TRUE)
}
vec_income_PhD = filter(df, Education == 'PhD')$Income
vec_income_Master = filter(df, Education == 'Master')$Income
vec_income_Graduation = filter(df, Education == 'Graduation')$Income
z.test.multiple_testing <- function(){
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
p_value_2 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_Master, sigma2=20160, test.type='two-sided', verbose=TRUE)
p_value_3 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_PhD, sigma2=20615, test.type='two-sided', verbose=TRUE)
return (p_value_1,p_value_2,p_value_3)
}
z.test.multiple_testing
z.test.multiple_testing()
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
df = read.csv('marketing_campaign.csv', sep='\t')
# Implementación de Z-test one-sided y two-sided
# Puede utilizar este esqueleto
z_test <- function(data1=NULL, sigma1=0.5, data2=NULL, sigma2=0.5,
mu.Ha=0, test.type = c('one-sided','two-sided'),
verbose=TRUE){
if(length(test.type)>=2){
print("Por favor escoge un tipo de Test: ´one-sided´ o ´two-sided´ ")
return()
}
else if(length(test.type)==1 && !(test.type %in% c('menor','mayor','two-sided'))){
print("Por favor escoge un tipo de Test: ´menor´, ´mayor´ o ´two-sided´")
return()
}
else if(is.null(data2)){
data_1_mean = mean(data1, na.rm=TRUE)
# P-value
if(test.type=='menor'){
p_value = pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='two-sided'){
if(data_1_mean>=mu.Ha){
p_value = (1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
else if(data_1_mean<mu.Ha){
p_value = (pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
}
# Texto de Salida
if(verbose){
cat("\tOne-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)), "\nZ=", Z_score,
"P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
else if(!is.null(data2)){
# Hypothesis test
data_1_mean = mean(data1, na.rm=TRUE)
data_2_mean = mean(data2, na.rm=TRUE)
resta = data_1_mean - data_2_mean
sigma_resta = sqrt((sigma1^2)/length(data1) + (sigma1^2)/length(data1))
# p-value
if(test.type=='menor'){
p_value = pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='two-sided'){
if(resta>=0){
p_value = (1 - pnorm(resta,mean=0, sd=sigma_resta))*2
}
else if(resta<0){
p_value = (pnorm(resta,mean=0, sd=sigma_resta))*2
}
}
# Texto de Salida
if(verbose){
cat("\tTwo-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)),"y",
deparse(substitute(data2)), "\nZ=",
Z_score, "P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
}
z_test
z_test()
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
deparse(substitute(vec_income_Graduation))
