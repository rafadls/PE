tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:500), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:5000), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:500), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1)
library(ggplot2)
library(reshape2)
# Definimos tamaños de muestreo
tamano_muestra = 30
n_muestras = 500
# Generamos una exponencial para luego generar el subsampling de ella
exponencial = rexp(10000, rate = 2)
#exponencial = rnorm(10000)
# Obtenemos la media poblacional de la exponencial
media_poblacional <- mean(exponencial)
# Sampling distribution, calculo del intervalo de confianza y proporción.
bool_c <- c()
medias <- c()
left <- c()
right <- c()
alpha <- 0.05
conteo_inside = 0
for (i in (1:n_muestras)){
sp <- sample(exponencial, tamano_muestra)
media <- mean(sp)
sigma <- sd(sp)
se <- sigma/sqrt(tamano_muestra)
error <- qnorm(1-alpha/2)*se
left <-rbind(left, media - error)
right <- rbind(right, media + error)
medias <- rbind(medias, media)
if((media - error) < media_poblacional & media_poblacional < (media + error)){
conteo_inside = conteo_inside + 1
}
bool_c <- rbind(bool_c, (media - error) < media_poblacional & media_poblacional < (media + error))
}
df <- data.frame(id = c(1:500), mean = medias, right_bound = right,  left_bound = left)
ggplot(df, aes(mean, id,  colour = factor(bool_c))) +
geom_pointrange(aes(xmin = left_bound, xmax = right_bound), size=0.1) +
geom_vline(xintercept = media_poblacional)
df = read.csv('marketing_campaign.csv', sep='\t')
df = read.csv('marketing_campaign.csv', sep='\t')
df = read.csv('marketing_campaign.csv', sep='\t')
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
Rscript.exe -e "Sys.getenv('R_LIBS_USER')"
library.path <- .libPaths()
library("timeseries", lib.loc = library.path)
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
install.packages("scatterplot3d")
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
# Para realizar plots
library(scatterplot3d)
df = read.csv('marketing_campaign.csv', sep='\t')
df = read.csv('marketing_campaign.csv', sep='\t')
directory <- ("./specdata/")
df = read.csv('marketing_campaign.csv', sep='\t')
setwd("C:/Users/Rafael/Desktop/U_2021_2/PE/T3")
df = read.csv('marketing_campaign.csv', sep='\t')
df
df$Income
df$Income.mean
df$Income.mean()
mean(df$Income)
mean(df$Income, na.remuve=TRUE)
mean(df$Income, na.rm=TRUE)
sqrt(1)
2^2
2^3
(2^3)/2
length(c(1,2))
df = read.csv('marketing_campaign.csv', sep='\t')
# Implementación de Z-test one-sided y two-sided
# Puede utilizar este esqueleto
z_test <- function(data1=NULL, sigma1=0.5, data2=NULL, sigma2=0.5,
mu.Ha=0, test.type = c('one-sided','two-sided'),
verbose=TRUE){
if(length(test.type)>=2){
print("Por favor escoge un tipo de Test: ´one-sided´ o ´two-sided´ ")
return()
}
else if(length(test.type)==1 && !(test.type %in% c('menor','mayor','two-sided'))){
print("Por favor escoge un tipo de Test: ´menor´, ´mayor´ o ´two-sided´")
return()
}
else if(is.null(data2)){
data_1_mean = mean(data1, na.rm=TRUE)
# P-value
if(test.type=='menor'){
p_value = pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='two-sided'){
if(data_1_mean>=mu.Ha){
p_value = (1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
else if(data_1_mean<mu.Ha){
p_value = (pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
}
# Texto de Salida
if(verbose){
cat("\tOne-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)), "\nZ=", Z_score,
"P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
else if(!is.null(data2)){
# Hypothesis test
data_1_mean = mean(data1, na.rm=TRUE)
data_2_mean = mean(data2, na.rm=TRUE)
resta = data_1_mean - data_2_mean
sigma_resta = sqrt((sigma1^2)/length(data1) + (sigma1^2)/length(data1))
# p-value
if(test.type=='menor'){
p_value = pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='two-sided'){
if(resta>=0){
p_value = (1 - pnorm(resta,mean=0, sd=sigma_resta))*2
}
else if(resta<0){
p_value = (pnorm(resta,mean=0, sd=sigma_resta))*2
}
}
# Texto de Salida
if(verbose){
cat("\tTwo-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)),"y",
deparse(substitute(data2)), "\nZ=",
Z_score, "P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
}
df$Income-df$Education
df$Income~df$Education
hola = df$Income~df$Education
hola = df$Income-df$Education
hola = df$Income-df$Education
df$Income-df$Education
View(df)
View(df)
filter(df, Education == 'PhD')
filter(df, Education == 'PhD')$Income
df$Education
vec_income_PhD = filter(df, Education == 'PhD')$Income
vec_income_Master = filter(df, Education == 'Master')$Income
vec_income_Graduation = filter(df, Education == 'Graduation')$Income
vec_income_PhD = filter(df, Education == 'PhD')$Income
vec_income_Master = filter(df, Education == 'Master')$Income
vec_income_Graduation = filter(df, Education == 'Graduation')$Income
z.test.multiple_testing <- function(){
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
p_value_2 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_Master, sigma2=20160, test.type='two-sided', verbose=TRUE)
p_value_3 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_PhD, sigma2=20615, test.type='two-sided', verbose=TRUE)
}
vec_income_PhD = filter(df, Education == 'PhD')$Income
vec_income_Master = filter(df, Education == 'Master')$Income
vec_income_Graduation = filter(df, Education == 'Graduation')$Income
z.test.multiple_testing <- function(){
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
p_value_2 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_Master, sigma2=20160, test.type='two-sided', verbose=TRUE)
p_value_3 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_PhD, sigma2=20615, test.type='two-sided', verbose=TRUE)
return (p_value_1,p_value_2,p_value_3)
}
z.test.multiple_testing
z.test.multiple_testing()
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
df = read.csv('marketing_campaign.csv', sep='\t')
# Implementación de Z-test one-sided y two-sided
# Puede utilizar este esqueleto
z_test <- function(data1=NULL, sigma1=0.5, data2=NULL, sigma2=0.5,
mu.Ha=0, test.type = c('one-sided','two-sided'),
verbose=TRUE){
if(length(test.type)>=2){
print("Por favor escoge un tipo de Test: ´one-sided´ o ´two-sided´ ")
return()
}
else if(length(test.type)==1 && !(test.type %in% c('menor','mayor','two-sided'))){
print("Por favor escoge un tipo de Test: ´menor´, ´mayor´ o ´two-sided´")
return()
}
else if(is.null(data2)){
data_1_mean = mean(data1, na.rm=TRUE)
# P-value
if(test.type=='menor'){
p_value = pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1)
}
else if(test.type=='two-sided'){
if(data_1_mean>=mu.Ha){
p_value = (1 - pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
else if(data_1_mean<mu.Ha){
p_value = (pnorm(data_1_mean,mean=mu.Ha, sd=sigma1))*2
}
}
# Texto de Salida
if(verbose){
cat("\tOne-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)), "\nZ=", Z_score,
"P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
else if(!is.null(data2)){
# Hypothesis test
data_1_mean = mean(data1, na.rm=TRUE)
data_2_mean = mean(data2, na.rm=TRUE)
resta = data_1_mean - data_2_mean
sigma_resta = sqrt((sigma1^2)/length(data1) + (sigma1^2)/length(data1))
# p-value
if(test.type=='menor'){
p_value = pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(resta,mean=mu.Ha, sd=sigma_resta)
}
else if(test.type=='two-sided'){
if(resta>=0){
p_value = (1 - pnorm(resta,mean=0, sd=sigma_resta))*2
}
else if(resta<0){
p_value = (pnorm(resta,mean=0, sd=sigma_resta))*2
}
}
# Texto de Salida
if(verbose){
cat("\tTwo-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)),"y",
deparse(substitute(data2)), "\nZ=",
Z_score, "P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
}
z_test
z_test()
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
deparse(substitute(vec_income_Graduation))
vec_income_PhD
mean_income_PhD = mean(vec_income_PhD, na.rm=TRUE)
mean_income_PhD
df
View(df)
uwu <- df[df[Education == 'PhD']]$Income
df = read.csv('marketing_campaign.csv', sep='\t')
# Implementación de Z-test one-sided y two-sided
# Puede utilizar este esqueleto
z_test <- function(data1=NULL, sigma1=0.5, data2=NULL, sigma2=0.5,
mu.Ha=0, test.type = c('one-sided','two-sided'),
verbose=TRUE){
if(length(test.type)>=2){
print("Por favor escoge un tipo de Test: ´one-sided´ o ´two-sided´ ")
return()
}
else if(length(test.type)==1 && !(test.type %in% c('menor','mayor','two-sided'))){
print("Por favor escoge un tipo de Test: ´menor´, ´mayor´ o ´two-sided´")
return()
}
else if(is.null(data2)){
mu_1 = mean(data1, na.rm=TRUE)
n_1 = length(data1)
Z_score = (mu_1 - mu.Ha)/(sigma1/sqrt(n_1))
# P-value
if(test.type=='menor'){
p_value = pnorm(Z_score)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(Z_score)
}
else if(test.type=='two-sided'){
if(mu_1>=mu.Ha){
p_value = (1 - pnorm(Z_score))*2
}
else if(mu_1<mu.Ha){
p_value = (pnorm(Z_score))*2
}
}
# Texto de Salida
if(verbose){
cat("\tOne-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)), "\nZ=", Z_score,
"P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
else if(!is.null(data2)){
# Hypothesis test
mu_1 = mean(data1, na.rm=TRUE)
mu_2 = mean(data2, na.rm=TRUE)
n_1 = length(data1)
n_2 = length(data2)
Z_score = (mu_2 - mu_1)/(sigma1/sqrt(n_1) +  sigma2/sqrt(n_2))
# p-value
if(test.type=='menor'){
p_value = pnorm(Z_score)
}
else if(test.type=='mayor'){
p_value = 1 - pnorm(Z_score)
}
else if(test.type=='two-sided'){
if(Z_score>=0){
p_value = (1 - pnorm(Z_score))*2
}
else if(Z_score<0){
p_value = pnorm(Z_score)*2
}
}
# Texto de Salida
if(verbose){
cat("\tTwo-sample Z-Test:\n\nData analizada:",
deparse(substitute(data1)),"y",
deparse(substitute(data2)), "\nZ=",
Z_score, "P-value=", p_value, "\n\n",sep=" ")
}
return(p_value)
}
}
uwu <- df[df[Education == 'PhD']]$Income
uwu <- df[df$Education == 'PhD']$Income
uwu <- df[df$Education == 'PhD', ]$Income
uwu
df$Education == 'PhD'
df[df$Education == 'PhD', ]
df[df$Education == 'PhD', ]
df[df$Education == 'PhD']
vec_income_PhD <- df[df$Education == 'PhD', ]$Income
vec_income_Master <- df[df$Education == 'Master', ]$Income
vec_income_Graduation <- df[df$Education == 'Graduation', ]$Income
#vec_income_PhD = filter(df, Education == 'PhD')$Income
#vec_income_Master = filter(df, Education == 'Master')$Income
#vec_income_Graduation = filter(df, Education == 'Graduation')$Income
z.test.multiple_testing <- function(){
print('Comprobar si la media de los ingresos para la variable Graduation es similar a 52000.')
p_value_1 = z_test(data1=vec_income_Graduation, sigma1=28180, mu.Ha=52000, test.type='two-sided', verbose=TRUE)
print('Compruebe si la diferencia entre los ingresos de las personas con el grado académico `Graduation` y `Master` es cercana a cero')
p_value_2 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_Master, sigma2=20160, test.type='two-sided', verbose=TRUE)
print('Compruebe si la diferencia entre los ingresos de las personas con el grado académico `Graduation` y `PhD` es cercana a cero')
p_value_3 = z_test(data1=vec_income_Graduation, sigma1=28180, data2=vec_income_PhD, sigma2=20615, test.type='two-sided', verbose=TRUE)
}
m
for (n in c(10,100,1000)){
largo_del_dataset = length(data$p.value)
prob_estimada <- c(1:largo_del_dataset)
prob_real <- c(1:largo_del_dataset)
alpha = 0.05
for (m in 1:largo_del_dataset){
prob_estimada[m] = 1-(1-alpha)^m
prob_real[m] = probEmpirica(alpha,m,n, Bonferroni = TRUE)
}
plot(c(1:m), prob_estimada, type = "l", col = "blue", xlim=c(1,m), ylim=c(0,1), ylab = "Probabilidad", xlab = "Número de muestras", main=
paste("Probabilidad de obtener un resultado significatívo, N = ",n))
lines(c(1:m), prob_real, type = "l", col = "orange")
legend(16, 0.2, legend=c("Probabilidad estimada", "Probabilidad real"),
col=c("blue", "orange"), lty=1:2, cex=0.8)
}
length(data$p.value)
data$p.value
data
data <- read.csv("ratones.csv",sep= ";", stringsAsFactors = T)
data$p.value <- sub(",",".",data$p.value)
data$p.value <- as.numeric(data$p.value)
data$p.value.Bonferroni <- sub(",",".",data$p.value.Bonferroni)
data$p.value.Bonferroni <- as.numeric(data$p.value.Bonferroni)
head(data)
probEmpirica <- function(alpha,m,n=100, Bonferroni = FALSE){
if (Bonferroni){
res = c(data$p.value.Bonferroni) #Resultados de los experimentos
}
else{
res = c(data$p.value) #Resultados de los experimentos
}
# Puede agergar todo el codigo que estime conveniente para calcular la probabilidad empirica
values <- vector()
for (i in 1:n){
muestra = sample(res, size = m, replace = T)
values[i] = any(alpha>=muestra)
}
prob <-sum(values)/n # Probabilidad empirica
return(prob)
}
for (n in c(10,100,1000)){
largo_del_dataset = length(data$p.value)
prob_estimada <- c(1:largo_del_dataset)
prob_real <- c(1:largo_del_dataset)
alpha = 0.05
for (m in 1:largo_del_dataset){
prob_estimada[m] = 1-(1-alpha)^m
prob_real[m] = probEmpirica(alpha,m,n, Bonferroni = TRUE)
}
plot(c(1:m), prob_estimada, type = "l", col = "blue", xlim=c(1,m), ylim=c(0,1), ylab = "Probabilidad", xlab = "Número de muestras", main=
paste("Probabilidad de obtener un resultado significatívo, N = ",n))
lines(c(1:m), prob_real, type = "l", col = "orange")
legend(16, 0.2, legend=c("Probabilidad estimada", "Probabilidad real"),
col=c("blue", "orange"), lty=1:2, cex=0.8)
}
